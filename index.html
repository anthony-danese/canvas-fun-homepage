<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AP Physics C: Mechanics and Electricity and Magnetism</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #fff;
      height: 100%;
      width: 100%;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive, sans-serif;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0; left: 0;
    }
    .instructions {
      position: absolute;
      z-index: 2;
      width: 100%;
      text-align: center;
      top: 16px;
      color: #222;
      font-size: 1.2rem;
      pointer-events: none;
      user-select: none;
      font-family: inherit;
      font-weight: bold;
      letter-spacing: 0.04em;
    }
  </style>
</head>
<body>
  <div class="instructions">Drag and drop the words! Platforms are fixed.</div>
  <div id="canvas-container"></div>
  <!-- Matter.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const {Engine, Render, Runner, World, Bodies, Mouse, MouseConstraint, Body} = Matter;

    // The two phrases as requested
    const topText = "AP Physics C: Mechanics";
    const bottomText = "Electricity and Magnetism";

    // Engine and world
    const engine = Engine.create();
    const world = engine.world;

    // Canvas sizing
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Renderer
    const render = Render.create({
      element: document.getElementById('canvas-container'),
      engine: engine,
      options: {
        width: w,
        height: h,
        wireframes: false,
        background: '#fff'
      }
    });

    Render.run(render);

    // Runner
    const runner = Runner.create();
    Runner.run(runner, engine);

    // Font and word sizing
    const fontSize = Math.min(68, Math.max(38, Math.floor(w / 15)));
    const wordPadding = 40;
    const platformWidth = Math.min(w*0.9, 1100);
    const platformOffsetX = (w-platformWidth)/2;
    const platformThickness = 8;

    // Platform Y positions
    const marginTop = 80;
    const spaceBetweenLines = fontSize * 3.2;
    const topPlatformY = marginTop + fontSize*1.2;
    const bottomPlatformY = topPlatformY + spaceBetweenLines;

    // Add platforms (static lines)
    const topPlatform = Bodies.rectangle(
      w/2, topPlatformY, platformWidth, platformThickness,
      { isStatic: true, 
        friction: 0.1,
        render: { fillStyle: "#333" }
      }
    );
    const bottomPlatform = Bodies.rectangle(
      w/2, bottomPlatformY, platformWidth, platformThickness,
      { isStatic: true, 
        friction: 0.1,
        render: { fillStyle: "#333" }
      }
    );
    World.add(world, [topPlatform, bottomPlatform]);

    // Create word bodies for each phrase
    // We'll use rectangle bodies for each word
    function makeWordBodies(phrase, yDrop) {
      const words = phrase.split(" ");
      const totalWidth = words.reduce((sum, word) => 
        sum + word.length * fontSize * 0.6 + wordPadding, 0
      );
      let startX = w/2 - totalWidth/2 + fontSize;
      let bodies = [];
      for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const width = word.length * fontSize * 0.6 + wordPadding;
        const body = Bodies.rectangle(
          startX + width/2,
          yDrop,
          width,
          fontSize + 20,
          {
            restitution: 0.6,
            friction: 0.01,
            density: 0.01,
            label: "word",
            render: {
              fillStyle: "#fff",
              strokeStyle: "#222",
              lineWidth: 3,
              customText: word,
              textColor: "#222"
            }
          }
        );
        body.isWord = true;
        body.text = word;
        body.width = width;
        bodies.push(body);
        startX += width;
      }
      return bodies;
    }

    // Create bodies for both lines
    const topWords = makeWordBodies(topText, marginTop);
    const bottomWords = makeWordBodies(bottomText, bottomPlatformY - fontSize*1.2);

    World.add(world, [...topWords, ...bottomWords]);

    // Floor and walls (to keep things in view)
    const wallThickness = 40;
    World.add(world, [
      Bodies.rectangle(w/2, h+wallThickness/2, w, wallThickness, {isStatic: true, render:{visible:false}}), // floor
      Bodies.rectangle(w/2, -wallThickness/2, w, wallThickness, {isStatic: true, render:{visible:false}}), // ceiling
      Bodies.rectangle(-wallThickness/2, h/2, wallThickness, h, {isStatic: true, render:{visible:false}}), // left
      Bodies.rectangle(w+wallThickness/2, h/2, wallThickness, h, {isStatic: true, render:{visible:false}}), // right
    ]);

    // Mouse control: Only let words be dragged!
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: 0.3,
        render: {visible: false}
      },
      filter: function(body) {
        return body.isWord === true;
      }
    });
    World.add(world, mouseConstraint);

    // Custom rendering of words over rectangles
    (function renderWords(){
      const ctx = render.context;
      ctx.save();
      // Draw platforms as hand-drawn lines
      ctx.strokeStyle = "#333";
      ctx.lineWidth = platformThickness;
      ctx.beginPath();
      ctx.moveTo(platformOffsetX, topPlatformY);
      ctx.bezierCurveTo(w/3, topPlatformY-8, 2*w/3, topPlatformY+8, w-platformOffsetX, topPlatformY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(platformOffsetX, bottomPlatformY);
      ctx.bezierCurveTo(w/3, bottomPlatformY-4, 2*w/3, bottomPlatformY+6, w-platformOffsetX, bottomPlatformY);
      ctx.stroke();

      // Draw all word bodies
      for(const body of [...topWords, ...bottomWords]){
        const pos = body.position;
        const angle = body.angle;
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle);

        // Draw rectangle background
        ctx.beginPath();
        ctx.rect(-body.width/2, -fontSize/2-10, body.width, fontSize+20);
        ctx.closePath();
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "#aaa";
        ctx.shadowBlur = 16;
        ctx.fill();
        ctx.lineWidth = body.render.lineWidth;
        ctx.strokeStyle = body.render.strokeStyle;
        ctx.stroke();

        // Draw word text
        ctx.font = `bold ${fontSize}px 'Comic Sans MS', 'Comic Sans', cursive, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = body.render.textColor;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 0;
        ctx.fillText(body.text, 0, 0);

        ctx.restore();
      }
      ctx.restore();
      window.requestAnimationFrame(renderWords);
    })();

    // Resize canvas on window resize
    window.addEventListener('resize', () => {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
    });

    // Give words a little drop animation
    setTimeout(()=>{
      [...topWords, ...bottomWords].forEach((body, idx) => {
        Body.applyForce(body, body.position, {
          x: (Math.random()-0.5)*0.04,
          y: Math.random()*0.04
        });
      });
    }, 500);

    // For mobile, make sure canvas is full screen
    render.canvas.style.position = "absolute";
    render.canvas.style.top = "0";
    render.canvas.style.left = "0";
    render.canvas.style.width = "100vw";
    render.canvas.style.height = "100vh";
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matter.js Bouncing Interactive Letters</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #fff; }
    canvas { display: block; border: none; outline: none; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
<script>
  const {
    Engine, Render, Runner, Bodies, Body, Composite,
    Mouse, MouseConstraint, Events
  } = Matter;

  // ----- Engine & render -----
  const engine = Engine.create();
  const render = Render.create({
    element: document.body,
    engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: '#ffffff'
    }
  });

  Render.run(render);
  const runner = Runner.create();
  Runner.run(runner, engine);

  const width = render.options.width;
  const height = render.options.height;

  // ----- World bounds -----
  const groundLine = Bodies.rectangle(width / 2, height - 2, width + 120, 6, {
    isStatic: true,
    render: { fillStyle: '#000000' }
  });
  groundLine.label = 'groundLine';

  const leftWall  = Bodies.rectangle(-30, height / 2, 60, height + 120, { isStatic: true, render:{visible:false} });
  const rightWall = Bodies.rectangle(width + 30, height / 2, 60, height + 120, { isStatic: true, render:{visible:false} });
  const ceiling   = Bodies.rectangle(width / 2, -30, width + 120, 60, { isStatic: true, render:{visible:false} });

  Composite.add(engine.world, [groundLine, leftWall, rightWall, ceiling]);

  // ----- Utilities -----
  function getRandomColor() {
    const h = Math.floor(Math.random() * 360);
    return `hsl(${h} 90% 55%)`;
  }

  function createTextTexture(text, color, size, family) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = "bold " + size + "px " + family;
    const textWidth = ctx.measureText(text).width;
    canvas.width = Math.max(1, Math.ceil(textWidth));
    canvas.height = Math.max(1, Math.ceil(size * 1.1));
    const ctx2 = canvas.getContext("2d");
    ctx2.font = "bold " + size + "px " + family;
    ctx2.textBaseline = "alphabetic";
    ctx2.lineWidth = Math.max(1, size / 18);
    ctx2.strokeStyle = "rgba(0,0,0,0.18)";
    ctx2.strokeText(text, 0, size * 0.82);
    ctx2.fillStyle = color;
    ctx2.fillText(text, 0, size * 0.82);
    return canvas.toDataURL("image/png");
  }

  function createLetter(letter, x, y, size=100, font="Arial, sans-serif") {
    if (letter === ' ') return null;
    const color = getRandomColor();

    const tempCanvas = document.createElement("canvas");
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.font = "bold " + size + "px " + font;
    const textWidth = tempCtx.measureText(letter).width;
    const textHeight = size;

    const body = Bodies.rectangle(x, y, textWidth, textHeight, {
      restitution: 0.9,
      friction: 0.2,
      frictionAir: 0.01,
      render: {
        sprite: {
          texture: createTextTexture(letter, color, size, font),
          xScale: 1,
          yScale: 1
        }
      }
    });

    // small spin & random angle
    //Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.4);
   //Body.setAngle(body, (Math.random() - 0.5) * 0.2);

    return body;
  }

  // Spacing and font
  let letterSpacing = 48;
  let fontSize = 100;

  // "iSTEM" - STEM first, then "i"
  let text = "iSTEM";
  let letters = text.split('');
  let stemLetters = letters.slice(1);
  let iLetter = letters[0];

  let lineX = width / 2;
  let lineY = height / 2;
  let totalWidth = (stemLetters.length - 1) * letterSpacing;
  let startX = lineX - totalWidth / 2;
  let y = lineY - 70;

  // Add STEM letters immediately
  stemLetters.forEach((char, idx) => {
    let x = startX + idx * letterSpacing;
    let letterBody = createLetter(char, x, y, fontSize);
    if (letterBody) Composite.add(engine.world, letterBody);
  });

  // Add "i" after 2 seconds
  setTimeout(() => {
    let iX = lineX - (totalWidth / 2) - letterSpacing-10;
    let iBody = createLetter(iLetter, iX, y, fontSize);
    if (iBody) Composite.add(engine.world, iBody);
  }, 2000);

  // ----- Mouse -----
  const mouse = Mouse.create(render.canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse,
    constraint: { stiffness: 0.2, render: { visible: false } }
  });
  Composite.add(engine.world, mouseConstraint);
  render.mouse = mouse;

  // ----- Trails -----
  const ctx = render.context;
  Events.on(render, 'afterRender', () => {
    ctx.save();
    ctx.globalAlpha = 0.12;
    engine.world.bodies.forEach(b => {
      if (b.render && b.render.sprite && b.render.sprite.texture) {
        const r = Math.max(4, (b.bounds.max.x - b.bounds.min.x)) * 0.08;
        ctx.beginPath();
        ctx.arc(b.position.x, b.position.y, r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fill();
      }
    });
    ctx.restore();
  });

  // ----- Keyboard tilt -----
  let gx = 0, gy = 1;
  document.addEventListener("keydown", function(event) {
    const key = event.key.toLowerCase();
    const step = 0.2;
    if (key === 'g') {
      if (engine.world.gravity.y === 0 && engine.world.gravity.x === 0) {
        engine.world.gravity.x = gx; engine.world.gravity.y = gy;
      } else {
        gx = engine.world.gravity.x; gy = engine.world.gravity.y;
        engine.world.gravity.x = 0; engine.world.gravity.y = 0;
      }
    }
    if (event.key === 'ArrowLeft')  gx -= step;
    if (event.key === 'ArrowRight') gx += step;
    if (event.key === 'ArrowUp')    gy -= step;
    if (event.key === 'ArrowDown')  gy += step;
    if (key === '0') { gx = 0; gy = 1; }
    engine.world.gravity.x = Math.max(-1, Math.min(1, gx));
    engine.world.gravity.y = Math.max(-1, Math.min(1, gy));
  });

  // ----- Resize -----
  window.addEventListener('resize', () => location.reload());
</script>
</body>
</html>

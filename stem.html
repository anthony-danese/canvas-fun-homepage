<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matter.js â€” iSTEM over Mr. Danese</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #fff; }
    canvas { display: block; border: none; outline: none; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
<script>
  const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint, Events } = Matter;

  const engine = Engine.create();
  const render = Render.create({
    element: document.body,
    engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: undefined    // let us paint our own background
    }
  });
  Render.run(render);
  Runner.run(Runner.create(), engine);

  const W = render.options.width;
  const H = render.options.height;

  // --- Background layers (Matter.js drawing, doesn't affect physics) ---
  // Gradient behind everything
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'destination-over';
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#f0f4ff');
    g.addColorStop(1, '#e0f7fa');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  });

  // Subtle vignette for contrast
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const r = Math.hypot(w, h) * 0.6;
    const vg = ctx.createRadialGradient(w/2, h/2, r*0.2, w/2, h/2, r);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  });

  // --- Floors and walls ---
  const ground = Bodies.rectangle(W/2, H - 2, W + 160, 6, { isStatic: true, render: { fillStyle: '#000' }});
  const floorY = Math.round(H * 0.55);
  const upperFloor = Bodies.rectangle(W/2, floorY, Math.min(W * 0.8, 900), 8, {
    isStatic: true, render: { fillStyle: '#111' }
  });
  const leftWall  = Bodies.rectangle(-40, H/2, 80, H+200, { isStatic: true, render:{visible:false} });
  const rightWall = Bodies.rectangle(W+40, H/2, 80, H+200, { isStatic: true, render:{visible:false} });
  const ceiling   = Bodies.rectangle(W/2, -40, W+200, 80, { isStatic: true, render:{visible:false} });

  Composite.add(engine.world, [ground, upperFloor, leftWall, rightWall, ceiling]);

  // --- Utilities (bright colors + crisp outlined textures) ---
  function randColor() {
    const h = Math.floor(Math.random() * 360);
    return `hsl(${h} 90% 55%)`;
  }

  function textTexture(text, color, size, font) {
    // measure first
    const meas = document.createElement('canvas').getContext('2d');
    meas.font = `bold ${size}px ${font}`;
    const w = Math.max(1, Math.ceil(meas.measureText(text).width));
    const h = Math.max(1, Math.ceil(size * 1.1));

    // HiDPI for crisp edges
    const ratio = Math.min(window.devicePixelRatio || 1, 2);
    const cnv = document.createElement('canvas');
    cnv.width = Math.ceil(w * ratio);
    cnv.height = Math.ceil(h * ratio);

    const ctx = cnv.getContext('2d');
    ctx.scale(ratio, ratio);
    ctx.font = `bold ${size}px ${font}`;
    ctx.textBaseline = 'alphabetic';

    // subtle outline for pop
    ctx.lineWidth = Math.max(1, size / 18);
    ctx.strokeStyle = 'rgba(0,0,0,0.22)';
    ctx.strokeText(text, 0, size * 0.82);

    // fill
    ctx.fillStyle = color;
    ctx.fillText(text, 0, size * 0.82);

    return cnv.toDataURL('image/png');
  }

  function createLetter(letter, x, y, size=100, font='Arial, sans-serif') {
    if (letter === ' ') return null;
    const color = randColor();
    const tmp = document.createElement('canvas').getContext('2d');
    tmp.font = `bold ${size}px ${font}`;
    const w = tmp.measureText(letter).width;
    return Bodies.rectangle(x, y, w, size, {
      restitution: 0.9,
      friction: 0.2,
      frictionAir: 0.01,
      render: { sprite: { texture: textTexture(letter, color, size, font) } }
    });
  }

  function measureWord(word, size=100, font='Arial, sans-serif', spacing=20) {
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.font = `bold ${size}px ${font}`;
    const letters = [...word];
    const widths = letters.map(ch => ch===' '? size*0.4 : ctx.measureText(ch).width);
    const total = widths.reduce((a,b)=>a+b,0) + spacing*(letters.length-1);
    return { total, widths };
  }

  function dropWord(word, cx, yDrop, size=100, font='Arial, sans-serif', spacing=20) {
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.font = `bold ${size}px ${font}`;
    const letters = [...word];
    const widths = letters.map(ch => ch===' '? size*0.4 : ctx.measureText(ch).width);
    const total = widths.reduce((a,b)=>a+b,0) + spacing*(letters.length-1);
    let cursor = cx - total/2;
    letters.forEach((ch,i)=>{
      const w = widths[i];
      const bx = cursor + w/2;
      const b = createLetter(ch,bx,yDrop,size,font);
      if (b) Composite.add(engine.world,b);
      cursor += w+spacing;
    });
    return { total, widths };
  }

  // --- Drop Mr. Danese a bit higher (still below upper floor) ---
  dropWord("Mr. Danese", W/2, H * 0.85);

  // --- Drop STEM + delayed i on upper floor ---
  const STEM_SIZE=100, STEM_SPACING=20;
  const { total: stemTotal } = measureWord("STEM", STEM_SIZE, "Arial", STEM_SPACING);

  setTimeout(()=>{
    const stemCenterX=W/2;
    dropWord("STEM", stemCenterX, floorY - 200, STEM_SIZE, "Arial", STEM_SPACING);

    setTimeout(()=>{
      const iX = stemCenterX - stemTotal/2 - STEM_SPACING - 20;
      dropWord("i", iX, floorY - 200, STEM_SIZE);
    },2000);
  },1500);

  // --- Mouse drag ---
  const mouse=Mouse.create(render.canvas);
  const mc=MouseConstraint.create(engine,{mouse,constraint:{stiffness:0.2,render:{visible:false}}});
  Composite.add(engine.world,mc);
  render.mouse=mouse;

  // --- Keyboard tilt ---
  let gx=0,gy=1;
  document.addEventListener("keydown",e=>{
    const key=e.key.toLowerCase(),step=0.2;
    if(key==='g'){
      if(engine.world.gravity.x===0&&engine.world.gravity.y===0){engine.world.gravity.x=gx;engine.world.gravity.y=gy;}
      else{gx=engine.world.gravity.x;gy=engine.world.gravity.y;engine.world.gravity.x=0;engine.world.gravity.y=0;}
    }
    if(e.key==='ArrowLeft') gx-=step;
    if(e.key==='ArrowRight') gx+=step;
    if(e.key==='ArrowUp') gy-=step;
    if(e.key==='ArrowDown') gy+=step;
    if(key==='0'){gx=0;gy=1;}
    engine.world.gravity.x=Math.max(-1,Math.min(1,gx));
    engine.world.gravity.y=Math.max(-1,Math.min(1,gy));
  });

  window.addEventListener('resize',()=>location.reload());
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matter.js Bouncing Interactive Letters</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #ffffff;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
<script>
  const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint, Events } = Matter;

  const engine = Engine.create();
  const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: undefined   // we paint our own background
    }
  });

  Render.run(render);
  Runner.run(Runner.create(), engine);

  // --- Background layers ---
  // Gradient background
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'destination-over';
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#f0f4ff');
    g.addColorStop(1, '#e0f7fa');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  });

  // Vignette overlay
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const r = Math.hypot(w, h) * 0.6;
    const vg = ctx.createRadialGradient(w/2, h/2, r*0.2, w/2, h/2, r);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  });

  // --- Boundaries ---
  const width = render.options.width;
  const height = render.options.height;
  const ground = Bodies.rectangle(width / 2, height + 30, width + 100, 60, { isStatic: true });
  const leftWall = Bodies.rectangle(-30, height / 2, 60, height, { isStatic: true });
  const rightWall = Bodies.rectangle(width + 30, height / 2, 60, height, { isStatic: true });
  const ceiling = Bodies.rectangle(width / 2, -30, width + 100, 60, { isStatic: true });
  Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

  // --- Platforms ---
  let lines = [
    { text: "AP Physics C", y: 100 },
    { text: "Mechanics &",  y: 200 },
    { text: "Electricity and Magnetism", y: 300 }
  ];
  let linePadding = 70;
  let lineX = width / 2;
  let lineWidth = Math.min(width * 0.8, 1200);

  let platformThickness = 5; // set to 2 if you want thinner lines
  lines.forEach((line) => {
    const platform = Bodies.rectangle(
      lineX,
      line.y + 25,
      lineWidth,
      platformThickness,
      {
        isStatic: true,
        render: {
          fillStyle: "#222",
          strokeStyle: "#222",
          lineWidth: platformThickness
        }
      }
    );
    Composite.add(engine.world, platform);
  });

  // --- Letters ---
  function getRandomColor() {
    const h = Math.floor(Math.random() * 360);
    return `hsl(${h} 90% 55%)`; // vivid colors
  }

  function createTextTexture(text, color, size, family) {
    const meas = document.createElement("canvas").getContext("2d");
    meas.font = "bold " + size + "px " + family;
    const w = Math.max(1, Math.ceil(meas.measureText(text).width));
    const h = Math.max(1, Math.ceil(size * 1.1));

    const ratio = Math.min(window.devicePixelRatio || 1, 2);
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(w * ratio);
    canvas.height = Math.ceil(h * ratio);

    const ctx = canvas.getContext("2d");
    ctx.scale(ratio, ratio);
    ctx.font = "bold " + size + "px " + family;
    ctx.textBaseline = "alphabetic";

    // subtle outline
    ctx.lineWidth = Math.max(1, size / 18);
    ctx.strokeStyle = "rgba(0,0,0,0.22)";
    ctx.strokeText(text, 0, size * 0.82);

    ctx.fillStyle = color;
    ctx.fillText(text, 0, size * 0.82);

    return canvas.toDataURL("image/png");
  }

  function createLetter(letter, x, y, size=64, font="Arial, sans-serif") {
    if (letter === ' ') return null;
    const color = getRandomColor();
    const tempCtx = document.createElement("canvas").getContext("2d");
    tempCtx.font = "bold " + size + "px " + font;
    const textWidth = tempCtx.measureText(letter).width;
    return Bodies.rectangle(x, y, textWidth, size, {
      restitution: 0.8,
      friction: 0.2,
      render: {
        sprite: {
          texture: createTextTexture(letter, color, size, font),
          xScale: 1,
          yScale: 1
        }
      }
    });
  }

  // Drop text lines
  let letterSpacing = 48;
  let fontSize = 64;
  lines.forEach((line) => {
    const chars = line.text.split('');
    const totalWidth = (chars.length - 1) * letterSpacing;
    const startX = lineX - totalWidth / 2;
    const y = line.y - linePadding;

    chars.forEach((char, idx) => {
      if (char !== ' ') {
        const x = startX + idx * letterSpacing;
        const letterBody = createLetter(char, x, y, fontSize);
        if (letterBody) Composite.add(engine.world, letterBody);
      }
    });
  });

  // Add "Mr. Danese"
  const nameText = "Mr. Danese";
  const nameY = lines[lines.length - 1].y + 120;
  const nameStartX = lineX - ((nameText.length - 1) * letterSpacing) / 2;

  nameText.split('').forEach((char, idx) => {
    if (char !== ' ') {
      const x = nameStartX + idx * letterSpacing;
      const letterBody = createLetter(char, x, nameY, fontSize);
      if (letterBody) Composite.add(engine.world, letterBody);
    }
  });

  // Mouse interaction
  const mouse = Mouse.create(render.canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: { stiffness: 0.2, render: { visible: false } }
  });
  Composite.add(engine.world, mouseConstraint);
  render.mouse = mouse;

  // Toggle gravity with 'G'
  document.addEventListener("keydown", function(event) {
    if (event.key.toLowerCase() === 'g') {
      engine.world.gravity.y = engine.world.gravity.y === 0 ? 1 : 0;
    }
  });

  // Handle window resize
  window.addEventListener('resize', () => { location.reload(); });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js Bouncing Interactive Letters</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #ffffff;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
<script>
    // Matter.js aliases
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Mouse = Matter.Mouse,
          MouseConstraint = Matter.MouseConstraint;

    // Create engine and renderer
    const engine = Engine.create();
    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: '#ffffff' // <-- pure white!
        }
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);

    // Boundaries
    const width = render.options.width;
    const height = render.options.height;
    const ground = Bodies.rectangle(width / 2, height + 30, width + 100, 60, { isStatic: true });
    const leftWall = Bodies.rectangle(-30, height / 2, 60, height, { isStatic: true });
    const rightWall = Bodies.rectangle(width + 30, height / 2, 60, height, { isStatic: true });
    const ceiling = Bodies.rectangle(width / 2, -30, width + 100, 60, { isStatic: true });
    Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

    // Platform lines (static bodies) - now visible!
    let lines = [
        { text: "AP Physics C", y: 100 },
        { text: "Mechanics &", y: 200 },
        { text: "Electricity and Magnetism", y: 300 }
    ];
    let linePadding = 70; // Padding above the line for letter drop
    let lineX = width / 2;
    let lineWidth = Math.min(width * 0.8, 1200);

    // Add visible platforms
    let platformThickness = 10;
    lines.forEach((line, i) => {
        let platform = Bodies.rectangle(
            lineX,
            line.y + 25,        // y-position of the horizontal line
            lineWidth,
            platformThickness,  // Thickness of the line
            {
                isStatic: true,
                render: {
                    fillStyle: "#222",
                    strokeStyle: "#222",
                    lineWidth: platformThickness
                }
            }
        );
        Composite.add(engine.world, platform);
    });

    // Utility functions
    function getRandomColor() {
        return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
    }

    function createTextTexture(text, color, size, family) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        ctx.font = "bold " + size + "px " + family;
        const textWidth = ctx.measureText(text).width;
        canvas.width = textWidth;
        canvas.height = size;
        ctx.font = "bold " + size + "px " + family;
        ctx.fillStyle = color;
        ctx.fillText(text, 0, size * 0.8); // vertically centered
        return canvas.toDataURL("image/png");
    }

    function createLetter(letter, x, y, size=64, font="Arial, sans-serif") {
        if (letter === ' ') return null;
        const color = getRandomColor();
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.font = "bold " + size + "px " + font;
        const textWidth = tempCtx.measureText(letter).width;
        const textHeight = size;
        return Bodies.rectangle(x, y, textWidth, textHeight, {
            restitution: 0.8,
            friction: 0.2,
            render: {
                sprite: {
                    texture: createTextTexture(letter, color, size, font),
                    xScale: 1,
                    yScale: 1
                }
            }
        });
    }

    // Add letters for each line, positioned above each platform
    let letterSpacing = 34; // <<<< Closer together!
    let fontSize = 64;
    lines.forEach((line, lineIndex) => {
        let chars = line.text.split('');
        let totalWidth = (chars.length - 1) * letterSpacing;
        let startX = lineX - totalWidth / 2;
        let y = line.y - linePadding;
        chars.forEach((char, idx) => {
            if (char !== ' ') {
                let x = startX + idx * letterSpacing;
                let letterBody = createLetter(char, x, y, fontSize);
                if (letterBody) Composite.add(engine.world, letterBody);
            }
        });
    });

    // Add letters for "Mr. Danese" below the last line
    let nameText = "Mr. Danese";
    let nameY = lines[lines.length-1].y + 120;
    let nameStartX = lineX - ((nameText.length - 1) * letterSpacing) / 2;
    nameText.split('').forEach((char, idx) => {
        if (char !== ' ') {
            let x = nameStartX + idx * letterSpacing;
            let letterBody = createLetter(char, x, nameY, fontSize);
            if (letterBody) Composite.add(engine.world, letterBody);
        }
    });

    // Mouse interaction
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.2,
            render: { visible: false }
        }
    });
    Composite.add(engine.world, mouseConstraint);
    render.mouse = mouse;

    // Toggle gravity with 'G'
    document.addEventListener("keydown", function(event) {
        if (event.key.toLowerCase() === 'g') {
            engine.world.gravity.y = engine.world.gravity.y === 0 ? 1 : 0;
        }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
        location.reload();
    });
</script>
</body>
</html>

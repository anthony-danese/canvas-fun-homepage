<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matter.js Bouncing Interactive Letters</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #ffffff;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
<script>
  // Matter.js aliases
  const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint,
        Events = Matter.Events;

  // Create engine and renderer
  const engine = Engine.create();
  const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: undefined   // important: let us paint the background manually
    }
  });

  Render.run(render);
  Runner.run(Runner.create(), engine);

  // --- Enhanced background & depth layers ---

  // 1) Gradient background behind everything
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'destination-over'; // draw behind existing pixels

    // Soft vertical gradient
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#f0f4ff');
    g.addColorStop(1, '#e0f7fa');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);

    ctx.restore();
  });

  // 2) Soft vignette to make the center pop (still behind letters)
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.canvas.width;
    const h = render.canvas.height;

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const r = Math.hypot(w, h) * 0.6;
    const vg = ctx.createRadialGradient(w/2, h/2, r*0.2, w/2, h/2, r);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  });

  // 3) Contact shadows under each letter for depth
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.20; // shadow strength

    engine.world.bodies.forEach(b => {
      if (b.render && b.render.sprite && b.render.sprite.texture) {
        const w = b.bounds.max.x - b.bounds.min.x;
        const h = b.bounds.max.y - b.bounds.min.y;
        const rx = Math.max(10, w * 0.48);
        const ry = Math.max(4,  h * 0.18);
        const cx = b.position.x;
        const cy = b.position.y + h * 0.46;

        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#000';
        ctx.fill();
      }
    });

    ctx.restore();
  });

  // Boundaries
  const width = render.options.width;
  const height = render.options.height;
  const ground = Bodies.rectangle(width / 2, height + 30, width + 100, 60, { isStatic: true });
  const leftWall = Bodies.rectangle(-30, height / 2, 60, height, { isStatic: true });
  const rightWall = Bodies.rectangle(width + 30, height / 2, 60, height, { isStatic: true });
  const ceiling = Bodies.rectangle(width / 2, -30, width + 100, 60, { isStatic: true });
  Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

  // Platform lines (static bodies) - visible
  let lines = [
    { text: "AP Physics C", y: 100 },
    { text: "Mechanics",    y: 200 }
  ];
  let linePadding = 70; // Padding above the line for letter drop
  let lineX = width / 2;
  let lineWidth = Math.min(width * 0.8, 1200);

  // Add visible platforms (same as your code; adjust thickness if you like)
  let platformThickness = 5;
  lines.forEach((line) => {
    const platform = Bodies.rectangle(
      lineX,
      line.y + 25,          // y-position of the horizontal line
      lineWidth,
      platformThickness,    // thickness of the line
      {
        isStatic: true,
        render: {
          fillStyle: "#222",
          strokeStyle: "#222",
          lineWidth: platformThickness
        }
      }
    );
    Composite.add(engine.world, platform);
  });

  // Utility functions (enhanced color + crisp letter texture)
  function getRandomColor() {
    const h = Math.floor(Math.random() * 360);
    return `hsl(${h} 90% 55%)`; // bright, saturated, readable
  }

  function createTextTexture(text, color, size, family) {
    // Measure first
    const meas = document.createElement("canvas").getContext("2d");
    meas.font = "bold " + size + "px " + family;
    const w = Math.max(1, Math.ceil(meas.measureText(text).width));
    const h = Math.max(1, Math.ceil(size * 1.1));

    // HiDPI scale for crisp edges
    const ratio = Math.min(window.devicePixelRatio || 1, 2);

    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(w * ratio);
    canvas.height = Math.ceil(h * ratio);

    const ctx = canvas.getContext("2d");
    ctx.scale(ratio, ratio);
    ctx.font = "bold " + size + "px " + family;
    ctx.textBaseline = "alphabetic";

    // Subtle outline for contrast
    ctx.lineWidth = Math.max(1, size / 18);
    ctx.strokeStyle = "rgba(0,0,0,0.22)";
    ctx.strokeText(text, 0, size * 0.82);

    // Fill
    ctx.fillStyle = color;
    ctx.fillText(text, 0, size * 0.82);

    return canvas.toDataURL("image/png");
  }

  function createLetter(letter, x, y, size=64, font="Arial, sans-serif") {
    if (letter === ' ') return null;
    const color = getRandomColor();

    const tempCtx = document.createElement("canvas").getContext("2d");
    tempCtx.font = "bold " + size + "px " + font;
    const textWidth = tempCtx.measureText(letter).width;
    const textHeight = size;

    return Bodies.rectangle(x, y, textWidth, textHeight, {
      restitution: 0.8,
      friction: 0.2,
      render: {
        sprite: {
          texture: createTextTexture(letter, color, size, font),
          xScale: 1,
          yScale: 1
        }
      }
    });
  }

  // Add letters for each line, positioned above each platform
  let letterSpacing = 48;
  let fontSize = 64;

  lines.forEach((line) => {
    const chars = line.text.split('');
    const totalWidth = (chars.length - 1) * letterSpacing;
    const startX = lineX - totalWidth / 2;
    const y = line.y - linePadding;

    chars.forEach((char, idx) => {
      if (char !== ' ') {
        const x = startX + idx * letterSpacing;
        const letterBody = createLetter(char, x, y, fontSize);
        if (letterBody) Composite.add(engine.world, letterBody);
      }
    });
  });

  // Add letters for "Mr. Danese" below the last line
  const nameText = "Mr. Danese";
  const nameY = lines[lines.length - 1].y + 120;
  const nameStartX = lineX - ((nameText.length - 1) * letterSpacing) / 2;

  nameText.split('').forEach((char, idx) => {
    if (char !== ' ') {
      const x = nameStartX + idx * letterSpacing;
      const letterBody = createLetter(char, x, nameY, fontSize);
      if (letterBody) Composite.add(engine.world, letterBody);
    }
  });

  // Mouse interaction
  const mouse = Mouse.create(render.canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.2,
      render: { visible: false }
    }
  });
  Composite.add(engine.world, mouseConstraint);
  render.mouse = mouse;

  // Toggle gravity with 'G'
  document.addEventListener("keydown", function(event) {
    if (event.key.toLowerCase() === 'g') {
      engine.world.gravity.y = engine.world.gravity.y === 0 ? 1 : 0;
    }
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    location.reload();
  });
</script>
</body>
</html>
